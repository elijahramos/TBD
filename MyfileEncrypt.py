import Myencrypt
import os
import cnsts

def norm(plainText):
    #fileString = open(filePath, "rb").read()            #personally I thought this was a dumb idea
    key = os.urandom(cnsts.keyLength)                   #Generate a 32 byte key
    fileEncrypt = Myencrypt.norm(plainText, key)       #Store the cipher and IV generated by Myencrypt.norm
    C = fileEncrypt[0]                                  #Create C variable to store the cipher from Myencrypt
    IV = fileEncrypt[1]                                 #Create IV variable to store the IV from Myencrypt
    #open((filePath+".enc"), "wb").write(C)              #this module handles NO file output
    return [C, IV, key]                  #Return C, IV, key, and the extension of the encrypted file as a string

# there was a conflict between these functions that basically breaks MyRSAEncrypt.inv()
# norm needed to return the filePath so that the inv could actually goto where the cipher text was, instead of simply having, the cipher text.
    
def inv(C, IV, key): # dispite what the lab paper says, I removed the requirement for passing the file ext because it is TOTALLY unessary.
    #fileString = open(filePath+ext, "rb").read()        #See first comment
    return Myencrypt.inv(C, IV, key)           #Return the decrypted bytes obtained from Myencrypt
    
