from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa # it contains a keygen, so these are needed
from cryptography.hazmat.primitives import serialization
import MyencryptMAC
import os
import cnsts
import pickle

def norm(filePath):
	fileObj = open(filePath, "rb") #open file, and save the referance for l8r
	location = filePath.rstrip(os.path.basename(fileObj.name)) # cut off the file's dir
	cutFile = (os.path.basename(fileObj.name)).partition('.') #place the file's name into a list [fileName, ., ext]
	
	# Yay Keygen, too bad I can have sick techno playing while this happens.
	#kg = rsa.generate_private_key(public_exponent=65537,key_size=2048,backend=default_backend())# its normally 2048
	#hmacKey = kg.private_bytes(encoding=serialization.Encoding.PEM,format=serialization.PrivateFormat.PKCS8,encryption_algorithm=serialization.NoEncryption())
	# ight here is the ordeal, so after thinking this over, I THINK I may have misunderstood him when he said that this wasnt nessary.
	# so while using this RSA key for the hmac may have worked out, it was rather unessary, instead im using a random number for the hmacKey.
	# it is way shorter and I dont have to do any cutting fuckery. anyway, at least thats nice.
	
	fileString = fileObj.read()
	key = os.urandom(cnsts.keyLength) #Generate a 32 byte key
	hmacKey = os.urandom(cnsts.hmacKeyLength) #Generate a key for the hmac
	fileEncrypt = MyencryptMAC.norm(fileString, key,hmacKey) #Store the cipher and IV generated by Myencrypt.norm
	C = fileEncrypt[0] #Create C variable to store the cipher from Myencrypt
	IV = fileEncrypt[1] #Create IV variable to store the IV from Myencrypt
	tag = fileEncrypt[2]#Create tag variable to store the tag from MyencryptMAC
	return [C, IV, key,location,cutFile[0],cutFile[2],tag,hmacKey] #Return C, IV, key,fileDir,fileName,fileExt,tag,HMACKey

# there was a conflict between these functions that basically breaks MyRSAEncrypt.inv()
# norm needed to return the filePath so that the inv could actually goto where the cipher text was, instead of simply having, the cipher text.
    
def inv(filePath, keyPath, HMACPath):
	# if the C byte string from the first function was directly saved to a file, actually ima make this a piclked file :3
	#this function can be called, along with the IV and key, to decrypt it.
	C = pickle.loads(open(filePath, "rb").read()) #more file IO stuffs, expect [C,IV,ext,tag]
	key = open(keyPath, "rb").read()# key should be raw
	mKey = open(keyPath, "rb").read()
	return [(MyencryptMAC.inv(C[0], C[1], key,C[3],mKey)),C[2]] #Return the decrypted bytes obtained from Myencrypt, and the ext
